%{

open Ast

let dbg value =
    //printfn "%s" (if obj.ReferenceEquals(value, null) then "(null)" else value.ToString())
    //printfn "%A" value
    value

%}

%start start
%type <Ast.program> start

%token AND OR
%token COLONEQ EQ
%token EQEQ NEQ GT GE LT LE
%token PLUS MINUS STAR SLASH PERCENT
%token LPAREN RPAREN
%token NOT AT COMMA DOT
%token RGB RGBA SRGB SRGBA KERNEL CONVOLUTE RECT
%token FOR IN YIELD DOTDOT
%token IF ELSE
%token LBRACE RBRACE
%token TRUE FALSE
%token QMARK COLON
%token LOG BLT
%token ABS SQRT SIN COS TAN ASIN ACOS ATAN ATAN2

%token EOF

%token <double> NUMBER
%token <string> STRING
%token <string> IDENT

%left AT NOT QMARK COLON OR
%left COMMA DOT
%right MINUS
%%

// ----------------------------- start

start: Program { $1 }

// ----------------------------- Statements

Program:
    | StatementList EOF                         { dbg (Statements $1) }

StatementList:
    | Statement StatementList                   { dbg ($1 :: $2) }
    | Statement                                 { dbg [$1] }

Statement:
    | IDENT COLONEQ Expr
                                                { dbg (Declaration($1, $3)) }
    | IDENT EQ Expr
                                                { dbg (Assignment($1, $3)) }
    | AT Atom EQ Expr
                                                { dbg (PixelAssign($2, $4)) }
    | IF Expr LBRACE StatementList RBRACE
                                                { dbg (IfThen($2, $4)) }
    | IF Expr LBRACE StatementList RBRACE ELSE LBRACE StatementList RBRACE
                                                { dbg (IfThenElse($2, $4, $8)) }
    | FOR IDENT IN Expr LBRACE StatementList RBRACE
                                                { dbg (ForIn($2, $4, $6)) }
    | FOR IDENT IN Molecule DOTDOT Molecule LBRACE StatementList RBRACE
                                                { dbg (ForInRange($2, $4, $6, $8)) }
    | YIELD Expr
                                                { dbg (Yield $2) }
    | LOG LPAREN MoleculeList RPAREN
                                                { dbg (Log ($3)) }
    | BLT Expr
                                                { dbg (Blt ($2)) }

// ----------------------------- Expression

Expr:
    | Expr QMARK Expr COLON Expr                { dbg (Conditional($1, $3, $5)) }
    | Expr OR AndExpr                           { dbg (Or($1, $3)) }
    | AndExpr                                   { $1 }

AndExpr:
    | AndExpr AND Cond                          { dbg (And($1, $3)) }
    | Cond                                      { $1 }

Cond:
    | Term EQEQ Term                            { dbg (Eq($1, $3)) }
    | Term NEQ Term                             { dbg (Neq($1, $3)) }
    | Term GT Term                              { dbg (Gt($1, $3)) }
    | Term GE Term                              { dbg (Ge($1, $3)) }
    | Term LT Term                              { dbg (Lt($1, $3)) }
    | Term LE Term                              { dbg (Le($1, $3)) }
    | Term IN Term                              { dbg (In($1, $3)) }
    | Term                                      { $1 }

Term:
    | Term PLUS Function                         { dbg (Plus($1, $3)) }
    | Term MINUS Function                        { dbg (Minus($1, $3)) }
    | Term STAR Function                         { dbg (Mul($1, $3)) }
    | Term SLASH Function                        { dbg (Div($1, $3)) }
    | Term PERCENT Function                      { dbg (Mod($1, $3)) }
    | Function                                   { $1 }

Function:
    | RGB LPAREN Molecule Molecule Molecule RPAREN
                                                { dbg (Rgb($3, $4, $5))}
    | RGBA LPAREN Molecule Molecule Molecule Molecule RPAREN
                                                { dbg (Rgba($3, $4, $5, $6))}
    | SRGB LPAREN Molecule Molecule Molecule RPAREN
                                                { dbg (Srgb($3, $4, $5))}
    | SRGBA LPAREN Molecule Molecule Molecule Molecule RPAREN
                                                { dbg (Srgba($3, $4, $5, $6))}
    | KERNEL LPAREN MoleculeList RPAREN
                                                { dbg (Kernel (List.rev $3))}
    | CONVOLUTE LPAREN Molecule Molecule RPAREN
                                                { dbg (Convolute ($3, $4))}
    | RECT LPAREN Molecule Molecule RPAREN
                                                { dbg (Rect ($3, $4))}
    | SIN LPAREN Molecule RPAREN
                                                { dbg (Sin ($3)) }
    | COS LPAREN Molecule RPAREN
                                                { dbg (Cos ($3)) }
    | TAN LPAREN Molecule RPAREN
                                                { dbg (Tan ($3)) }
    | ASIN LPAREN Molecule RPAREN
                                                { dbg (Asin ($3)) }
    | ACOS LPAREN Molecule RPAREN
                                                { dbg (Acos ($3)) }
    | ATAN LPAREN Molecule RPAREN
                                                { dbg (Atan ($3)) }
    | ATAN2 LPAREN Molecule Molecule RPAREN
                                                { dbg (Atan2 ($3, $4)) }
    | ABS LPAREN Molecule RPAREN
                                                { dbg (Abs ($3)) }
    | SQRT LPAREN Molecule RPAREN
                                                { dbg (Sqrt ($3)) }
    | Molecule
                                                { $1 }

Molecule:
    | MINUS Atom                                { dbg (Neg $2) }
    | NOT Atom                                  { dbg (Not $2) }
    | Atom DOT IDENT                            { dbg (MemberInvoke($1, $3)) }
    | Atom                                      { $1 }

MoleculeList:
    | Molecule MoleculeList                     { dbg ($1 :: $2) }
    | Molecule                                  { dbg [$1] }

Atom:
    | LPAREN Expr RPAREN                        { dbg $2 }
    | AT Atom                                   { dbg (At $2) }
    | Atom COMMA Atom                           { dbg (Pos($1, $3)) }
    | IDENT                                     { dbg (Ident $1) }
    | NUMBER                                    { dbg (Number $1) }
    | STRING                                    { dbg (String $1) }
    | TRUE                                      { dbg (Boolean true) }
    | FALSE                                     { dbg (Boolean false) }
